#include <assert.h>
#include <cerrno>
#include <csignal>
#include <fcntl.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <vector>
const ssize_t k_max_msg = 4096;
struct Conn {
  int fd = -1;
  // application's intention, for the event loop
  bool want_read = false;
  bool want_write = false;
  bool want_close = false;
  // buffered input and output
  std::vector<uint8_t> incoming; // data to be parsed by the application
  std::vector<uint8_t> outgoing; // responses generated by the application
};
void fd_set_nb(int fd) {
  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}
Conn *handle_accept(int fd) {
  struct sockaddr_in clientAddr = {};
  socklen_t socklen = sizeof(clientAddr);
  int connfd = accept(fd, (struct sockaddr *)&clientAddr, &socklen);
  if (connfd < 0) {
    return NULL;
  }
  fd_set_nb(connfd);
  Conn *conn = new Conn();
  conn->fd = connfd;
  conn->want_read = true;
  return conn;
}
void handle_read(Conn *conn) {}
void handle_write(Conn *conn) {}
int32_t readFull(int fd, char *buf, size_t n) {
  while (n > 0) {
    ssize_t rv = read(fd, buf, n);
    if (rv <= 0) {
      return -1;
    }
    assert((size_t)rv <= n);
    n -= (size_t)rv;
    buf += rv;
  }

  return 0;
}

int32_t writeAll(int fd, char *buf, size_t n) {
  while (n > 0) {
    ssize_t rv = write(fd, buf, n);
    if (rv <= 0) {
      return -1;
    }
    assert((size_t)rv <= n);
    n -= (size_t)rv;
    buf += rv;
  }

  return 0;
}
int32_t one_request(int connfd) {
  char lenBuf[4];
  int32_t rLen = 0;
  char rbuf[k_max_msg];
  ssize_t rv = readFull(connfd, lenBuf, 4);
  if (rv) {
    return -1;
  }
  memcpy(&rLen, lenBuf, 4);
  if (rLen > k_max_msg) {
    printf("too long\n");
    return -1;
  }
  rv = readFull(connfd, rbuf, rLen);
  if (rv) {
    return -1;
  }
  printf("client says: %d %s\n", rLen, rbuf);

  char reply[] = "world";
  int32_t wLen = strlen(reply);
  char wBuf[4 + wLen];

  memcpy(wBuf, &wLen, 4);
  memcpy(wBuf + 4, reply, wLen);

  rv = writeAll(connfd, wBuf, 4 + wLen);

  return rv;
}
int main() {
  std::vector<Conn *> fd2Conn;
  int fd = socket(AF_INET, SOCK_STREAM, 0);
  struct sockaddr_in addr = {};
  addr.sin_family = AF_INET;
  addr.sin_port = htons(8080);
  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
  int bindRes = bind(fd, (const struct sockaddr *)&addr, sizeof(addr));
  if (bindRes) {
    return bindRes;
  }
  int listenRes = listen(fd, SOMAXCONN);
  if (listenRes) {
    return listenRes;
  }
  std::vector<struct pollfd> poll_args;
  while (true) {
    poll_args.clear();
    struct pollfd lpfd = {fd, POLL_IN, 0};
    poll_args.push_back(lpfd);
    for (Conn *conn : fd2Conn) {
      if (!conn) {
        continue;
      }
      struct pollfd pfd = {conn->fd, POLL_ERR, 0};
      if (conn->want_read) {
        pfd.events |= POLL_IN;
      }
      if (conn->want_write) {
        pfd.events |= POLL_OUT;
      }
      poll_args.push_back(pfd);
    }

    int rv = poll(poll_args.data(), poll_args.size(), -1);
    if (rv < 0) {
      if (errno == EINTR)
        continue;
      else
        return -1;
    }
    if (poll_args.front().revents) {
      Conn *conn = handle_accept(poll_args.front().fd);
      if (conn) {
        if (fd2Conn.size() <= conn->fd) {
          fd2Conn.resize(conn->fd + 1);
        }
        fd2Conn[conn->fd] = conn;
      }
    }
    for (int i = 1; poll_args.size(); i++) {
      int state = poll_args[i].revents;
      Conn *conn = fd2Conn[poll_args[i].fd];
      if (state & POLL_IN) {
        handle_read(conn);
      }
      if (state & POLL_OUT) {
        handle_write(conn);
      }
      if (state & POLL_ERR || conn->want_close) {
        close(conn->fd);
        fd2Conn[poll_args[i].fd] = NULL;
        delete conn;
      }
    }
  }
  return 0;
}
